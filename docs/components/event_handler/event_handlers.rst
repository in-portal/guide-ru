Обработчики событий
===================
`Data Source`_
`Eng Data Source`_

Обработчики событий позволяют выполнять действия на основании данных пользователя, попадающих в PHP через
специальным образом сформированные запросы на сервер. Ниже приведены основные аспекты написания обработчиков
событий, которые призваны помочь с минимальными усилиями написать требуемый обработчик события.

Получение объекта, участника события
====================================

- Если известно, что ID объекта доступно в запросе пользователя, то нужно использовать следующий код:

.. code:: php

   $object =& $event->getObject();

Этот код не только получит объект, но и загрузит в него данные по ID найденному в запросе пользователя.

- Если про ID объекта ничего не известно, то нужно использовать следующий код:

.. code:: php

   $object =& $event->getObject( Array('skip_autoload' => true) );

Такой подход использован в событиях :doc:`/events/live_editing/on_create` и
:doc:`/events/live_editing/on_update`, т.к. в первом из них ID нету вообще, а втором может
быть за раз передано более одного ID.

.. _получение_данных_из_формы:

Получение данных из формы
=========================

Получить данные из формы (только в случае, если был использован POST запрос) можно использовав следующий код:

.. code:: php

   $items_info = $this->Application->GetVar( $event->getPrefixSpecial(true) );

Обработка данных из формы
=========================

- В случае, если передано только одно ID, то массив ``$items_info`` (см. пример :ref:`получение_данных_из_формы`)
  нужно использовать следующим образом:

.. code:: php

   if ($items_info) {
       list ($id, $field_values) = each($items_info);
       // обработка данных
   }

- В случае, когда из запроса могут быть получены данные сразу нескольких объектов, то нужно использовать
  следующий код:

.. code:: php

   if ($items_info) {
       foreach ($items_info as $id => $field_values) {
           // обработка данных
       }
   }

Указание шаблона для перенаправления
====================================

После успешного выполнения обработчика события автоматически происходит перенаправление на текущий шаблон
(на Front-End) или на шаблон со списком, из которого был открыт данный шаблон (в Admin). Если требуется
указать шаблон, отличный от шаблона подставляемого автоматически нужно использовать атрибут
``redirect`` объекта ``$event``:

.. code:: php

   $event->redirect = 'template_name';

.. caution::

   Название шаблонов для перенаправления не следует "зашивать" (hardcoded) в коде. Их лучше всего передавать
   из формы, в которой было вызвано событие.

На данный момент механизм работы с всплывающими окнами (popups) построен таким образом, что значение
атрибута ``redirect`` будет проигнорировано. Независимо от этого на Front-End будет учитываться значение
данного атрибута. Но надо отметить, что если будет нужно изменить шаблон для перенаправления у событий
:doc:`/events/live_editing/on_create` или :doc:`/events/live_editing/on_update`, то нужно перед
присваиванием шаблона выполнить следующий код:

.. code:: php

   $event->SetRedirectParam('opener', 's');

Если используются другие обработчики событий, то этого делать не нужно.

Вызов нового события из обработчика событий
===========================================

- Для вызова нового события с таким же :ref:`префиксом <uc_Prefix>`, как у текущего события (откуда выполняется код) нужно написать следующий код:

.. code:: php

   $event->CallSubEvent('OnSampleEvent');

- Для вызова события у которого :ref:`префикс <uc_Prefix>` отличается от текущего нужно написать следующий код:

.. code:: php

   $this->Application->HandleEvent( new kEvent('prefix.special:OnSampleEvent') );

.. note::

   Если special не используется, то и точку ставить не надо.

Сопоставление прав доступа и обработчика события
================================================

Если пишется обработчик события, которое не описано в классе ``kDBEventHandler``, то права доступа,
необходимые для выполнения данного события нужно указать в методе ``kEventHandler::mapPermissions``:

.. code:: php

   function mapPermissions()
   {
       parent::mapPermissions();
       $permissions = Array (
           'OnSampleEvent' => Array ('self' => 'main_permissions', 'subitem' => 'subitem_permissions'),
       );

       $this->permMapping = array_merge($this->permMapping, $permissions);
   }

Если в :doc:`unit config </components/unit_configs/configuration_files>`, в котором указан класс, содержащий
обработчик события находиться опция :ref:`uc_SubItems`, то названия прав доступа нужно указывать в ключе
``self``. Если такой опции нету, то названия прав доступа нужно указывать в ключе ``subitem``.
Если требуется указать несколько прав доступа одновременно, то нужно их разделять используя вертикальную черту
(``|``). В таком случае у пользователя будет проверяться наличие хотя бы одного из перечисленных прав. Если
для выполнения события никакие права не нужны, то нужно указать ``true`` вместо строки с названиями прав.

.. caution::

   В методе mapPermissions запрещается использовать :ref:`управляющие структуры <coding_style_control_structures>`.

.. _Data Source: http://guide.in-portal.org/rus/index.php/K4:%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8_%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9
.. _Eng Data Source: http://guide.in-portal.org/eng/index.php/K4:Event_Handlers
